#pragma kernel LemmingsMovementPassKernel
#include "LemmingsSimulationShared.cginc"

RWStructuredBuffer<Lemming> _Lemmings;
Texture2D _collisionBitMap;
Texture2D _terrainAnalysisTexture;
SamplerState _point_clamp_Sampler;

bool _Simulate;
#define Gravity  4.9

void FixOutOfBounds(inout Lemming lemming, float2 posUV)
{
    lemming.Velocity.x = posUV.x >= 1 ? -lemming.Velocity.x : lemming.Velocity.x;
    lemming.Velocity.x = posUV.x <= 0 ? -lemming.Velocity.x : lemming.Velocity.x;
    lemming.Velocity.y = posUV.y <= 0 ? 0 : lemming.Velocity.y;
    lemming.Position = clamp(lemming.Position, _MinBound, _MaxBound);
}

rect GetLemmingCollision(Lemming lemming)
{
    float2 p = (lemming.Position + lemming.Velocity * _DeltaTime);

    float2 hs = _lemmingSize / 2;
    float2 c = pointInSquarePerimeter(lemming.Position, lemming.Velocity, lemming.Position - hs,
                                      lemming.Position + hs);

    float2 Max = -1000;
    float2 Min = 1000;
    float2 puv;
    #define ARRSIZE 1
    float2 corners[ARRSIZE] = {p + c};
    //, p, p - float2(0, 1) * _lemmingSize / 2, p + float2(0, 1) * _lemmingSize / 2};
    [unroll(ARRSIZE)]
    for (int i = 0; i < ARRSIZE; i++)
    {
        puv = (computeUV(corners[i]));
        float2 pixelPos = computePos(computePixelUV(puv, 0));
        if (_collisionBitMap.SampleLevel(_point_clamp_Sampler, puv, 0).x == 0.0)
        {
            float4 SDFColor = _terrainAnalysisTexture.SampleLevel(_point_clamp_Sampler, puv, 0);
            float2 nsdf = normalize(SDFColor.rg);
            float2 sdfPixelUV = computePixel(computePixelUV(puv + nsdf * SDFColor.b, 0.5));

            sdfPixelUV /= _texDimensions;
            float2 psdf = computePos(computePixelUV(sdfPixelUV, 0));

            Max = max(Max, max(pixelPos, psdf));
            Min = min(Min, min(pixelPos, psdf));
            psdf = max(Max, Min);
            Min = min(Max, Min);
            Max = psdf;
            Max = max(Max, pixelPos + PixelSize * 0.5f);
            Min = min(Min, pixelPos - PixelSize * 0.5f);
        }
    }
    rect collisionPixel;
    collisionPixel.Position = (Max + Min) / 2.0f;
    collisionPixel.Size = Max - Min;
    return collisionPixel;
}

bool IsNaN(float x)
{
    return (asuint(x) & 0x7fffffff) > 0x7f800000;
}


void FixCollision(float2 projPos, float2 currPos, rect pixel, inout Lemming lemming)
{
    float2 hs = pixel.Size * 0.5;
    float2 Sign = GetCardinalDirection(currPos, lemming.Velocity, pixel.Position - hs, pixel.Position + hs);
    //normalization missing
    float2 proj = project((projPos - pixel.Position), Sign.yx);
    float2 displacement = proj + Sign * (hs + _lemmingSize * 0.5f);

    float2 x = pixel.Position + displacement;
    if (IsNaN(x) == false)
    {
        lemming.Position = x;
        float L = length(lemming.Velocity);
        //lemming.Velocity = 0;
        lemming.Velocity += abs(Sign.yx * 0.01f);

        lemming.Velocity = normalize(abs(Sign.yx)) * lemming.Velocity;
        lemming.Velocity = normalize(lemming.Velocity) * clamp(L, 0, _lemmingSize.x * 2);
    }
}

[numthreads(512,1,1)]
void LemmingsMovementPassKernel(uint3 id : SV_DispatchThreadID)
{
    Lemming lemming = _Lemmings[id.x];
    rect pixel = GetLemmingCollision(lemming);
    float2 p = lemming.Position + lemming.Velocity * _DeltaTime;

    bool2 collides = pixel.Size != float2(-1000 - 1000, -1000 - 1000);
    if (collides.x || collides.y)
    {
        FixCollision(p, lemming.Position, pixel, lemming);
    }

    lemming.Acceleration = -float2(0, Gravity);
    lemming.Velocity += lemming.Acceleration * _DeltaTime;
    lemming.Position += lemming.Velocity * _DeltaTime;
    lemming.Acceleration = 0;

    FixOutOfBounds(lemming, computeUV(lemming.Position));
    _Lemmings[id.x] = lemming;
}
