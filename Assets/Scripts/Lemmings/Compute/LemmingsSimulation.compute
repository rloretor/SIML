#pragma kernel LemmingsMovementPassKernel

struct Lemming
{
    float2 Position;
    float2 Velocity;
};

RWStructuredBuffer<Lemming> _Lemmings;
Texture2D _collisionBitMap;
SamplerState _linearClampSampler;

cbuffer once {float2 _MaxBound; float2 _MinBound; float _DeltaTime; float _Time;};

#define Gravity  9.8

float2 computeUV(float2 position)
{
    return (position - _MinBound) / (_MaxBound - _MinBound);
}

//https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl
float hash(float2 x)
{
    return frac(sin(dot(x, float2(12.9898, 78.233))) * 43758.5453);
}

[numthreads(512,1,1)]
void LemmingsMovementPassKernel(uint3 id : SV_DispatchThreadID)
{
    Lemming lemming = _Lemmings[id.x];

    lemming.Velocity.y -= Gravity * _DeltaTime;

    float2 projectedPosition = lemming.Position + lemming.Velocity * _DeltaTime;

    lemming.Velocity.x = projectedPosition.x >= _MaxBound.x ? -lemming.Velocity.x : lemming.Velocity.x;
    lemming.Velocity.x = projectedPosition.x <= _MinBound.x ? -lemming.Velocity.x : lemming.Velocity.x;

    lemming.Velocity.y = projectedPosition.y >= _MaxBound.y ? -lemming.Velocity.y : lemming.Velocity.y;
    lemming.Velocity.y = projectedPosition.y <= _MinBound.y ? -lemming.Velocity.y : lemming.Velocity.y;


    float2 uv = computeUV(projectedPosition);
    const bool isProjectedCollision = round(_collisionBitMap.SampleLevel(_linearClampSampler, uv, 0).a);

    lemming.Position = isProjectedCollision
                           ? lemming.Position + float2(0, 100) * _DeltaTime
                           : projectedPosition;
    lemming.Position = clamp(lemming.Position, _MinBound, _MaxBound);

    _Lemmings[id.x] = lemming;
}
