#pragma kernel LemmingsMovementPassKernel
#include "../Shared/LemmingsSimulationShared.cginc"


RWStructuredBuffer<Lemming> _Lemmings;
Texture2D _collisionBitMap;
Texture2D _terrainAnalysisTexture;
SamplerState _point_clamp_Sampler;

bool _Simulate;
#define Gravity  4.9

void FixOutOfBounds(inout Lemming lemming, float2 posUV)
{
    lemming.Velocity.x = posUV.x >= 1 ? -lemming.Velocity.x : lemming.Velocity.x;
    lemming.Velocity.x = posUV.x <= 0 ? -lemming.Velocity.x : lemming.Velocity.x;
    lemming.Velocity.y = posUV.y <= 0 ? 0 : lemming.Velocity.y;
    lemming.Position = clamp(lemming.Position, _MinBound, _MaxBound);
}

rect GetLemmingCollision(float2 p)
{
    float2 s = _lemmingSize;
    float2 d = float2(1, 0);
    const float2 corners[5] =
    {
        float2(p - s),
        float2(p + d.xy * s.x - d.yx * s.y),
        float2(p - d.yx * s),
        float2(p + d.xy * s.x),
        float2(p - d.xy * s.x),
    };
    const float2 pixelSize = WorldSize / _texDimensions;

    float2 maxS = -1000.0;
    float2 minS = 1000.0;
    float2 puv;
    for (int i = 0; i < 5; i++)
    {
        puv = computeUV(corners[i]);
        float2 pixelPos = computePos(computePixelUV(puv, 0.5));

        if (_collisionBitMap.SampleLevel(_point_clamp_Sampler, puv, 0).x == 0.0)
        {
            maxS = max(maxS, pixelPos + pixelSize / 2);
            minS = min(minS, pixelPos - pixelSize / 2);
        }
    }

    rect collisionPixel;
    collisionPixel.Position = (maxS + minS) / 2.0;
    collisionPixel.Size = (maxS - minS);
    return collisionPixel;
}

void FixCollision(inout Lemming lemming, rect pixel)
{
    float t = 0;
    float2 n = 0;
    float2 dvdt = lemming.Velocity * _DeltaTime;
    bool c = Ray2Rect(pixel, lemming.Position, dvdt, t, n);
    if (c)
    {
        float2 newPosition = lemming.Position + dvdt * t;
        lemming.Position = newPosition;

        lemming.Velocity = n.yx;
        lemming.Velocity.y *= 0.2f;
        lemming.Velocity = normalize(lemming.Velocity) * clamp(length(lemming.Velocity), 0.1, 10.0);
        lemming.Velocity += lemming.Acceleration;
    }

    lemming.Position = lemming.Position + lemming.Velocity * _DeltaTime;
}


[numthreads(512,1,1)]
void LemmingsMovementPassKernel(uint3 id : SV_DispatchThreadID)
{
    // if (_Simulate)
    {
        Lemming lemming = _Lemmings[id.x];
        float2 uv = computeUV(lemming.Position + lemming.Velocity * _DeltaTime);
        rect pixel = GetLemmingCollision(lemming.Position + lemming.Velocity * _DeltaTime);
        bool2 collides = pixel.Size != (-2000.0); // maybe
        if (collides.x || collides.y)
        {
            float3 sizeExtra = _terrainAnalysisTexture.SampleLevel(_point_clamp_Sampler, computePixelUV(uv, 0.5), 0);
            sizeExtra.xy *= sizeExtra.z * WorldSize * 2;
            //pixel.Size = max(pixel.Size, sizeExtra.xy);
            pixel.Size += _lemmingSize / 2.0f;
            FixCollision(lemming, pixel);
        }
        else
        {
            lemming.Acceleration = -float2(0, Gravity);
            lemming.Velocity += lemming.Acceleration * _DeltaTime;
            lemming.Position += lemming.Velocity * _DeltaTime;
            lemming.Acceleration = 0;
        }
        FixOutOfBounds(lemming, uv);
        _Lemmings[id.x] = lemming;
    }
}
